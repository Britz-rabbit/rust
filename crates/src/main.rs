// • 包（Packages）：Cargo 的一个功能，它允许你构建、测试和分享 crate。
// • Crates ：一个模块的树形结构，它形成了库或二进制项目。
// • 模块（Modules）和 use：允许你控制作用域和路径的私有性。
// • 路径（path）：一个命名例如结构体、函数或模块等项的方式

// crate是最小的代码单位，包括二进制项和库两种形式，一个carte必须要包括一个main.rs，是一段可运行的程序。通常在做项目的时候，这些carte都是以库的形式存在的
// packages是包含多个crate的一系列功能
// • 模块中的代码路径: 一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一
// 个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模
// 块下的Asparagus类型可以在crate:: garden::vegetables::Asparagus被找到。

// • 私有 vs 公用: 一个模块里的代码默认对其父模块私有。为了使一个模块公用，应当在声明时使
// 用pub mod替代mod。为了使一个公用模块内部的成员公用，应当在声明前使用pub。

// • use 关键字: 在一个作用域内，use关键字创建了一个成员的快捷方式，用来减少长路径的重复。在任
// 何可以引用crate:: garden::vegetables::Asparagus的作用域, 你可以通过use crate::garden::vegetables::Aspara建一个快捷方式，
// 然后你就可以在作用域中只写Asparagus来使用该类型。

// 模块不仅对于你组织代码很有用。他们还定义了 Rust 的 私有性边界（privacy boundary）：这条界线不
// 允许外部代码了解、调用和依赖被封装的实现细节。所以，如果你希望创建一个私有函数或结构体，你可以将其放入模块。

// Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子
// 模块中的私有项，但是子模块中的项可以使用他们父模块中的项。这是因为子模块封装并隐藏了他们的
// 实现详情，但是子模块可以看到他们定义的上下文。

// 使用以 super 开头的相对路径从父目录开始调用函数

//通过mod 文件名直接引入文件中所有的pub内容
mod test_mod;
//通过use 路径一次性引入我们需要的那部分内容
use test_mod::eat_at_reastaurant;
use test_mod::hosting::test_fn;
fn main() {
    println!("Hello, world!");
    eat_at_reastaurant();
    test_fn();
} 


// 要想使用 use 将函数的父模块引入作用域，我们必须在调用函数时指定父模块，这样可以清晰地表明函数
// 不是在本地定义的，同时使完整路径的重复度最小化。示例 7-13 中的代码不清楚 add_to_waitlist 是在哪里被定义的。
// 另一方面，使用 use 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。示例 7-14 展示了将
// HashMap 结构体引入二进制 crate 作用域的习惯用法。

